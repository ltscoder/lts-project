回溯：
回溯+dfs(递归，非递归B12NQueen.dfsWithNoRecursion)

~dfs+回溯代码结构：
dfsMethod：
1结束条件，根据是否到达深度了，到深度了就return。
2对广度，再做dfs和回溯。~可能可以剪枝，提前结束。





关于排列和组合：
1排列中使用boolean[] used = new boolean[nums.length]，解决的问题是 用过的元素不能再用
2排序+(nums[i] == nums[i - 1] && used[i - 1] == 0)判断,解决的问题是 nums相同值的元素导致的重复的排列。
3排序+for循环从上一个index+1开始，解决的问题是 nums数组没有相同值的元素时由于排序不同导致的重复的组合。
4排序+(nums[i] == nums[i - 1] && used[i - 1] == 0)
 或者优化为排序+ i > index && input[i] == input[i-1]，具体参考B3combine.dfsCombine2方法。
 解决的问题是 nums数组有相同值的元素导致的重复的排列/组合。
 所以【给定一个有重复元素的int数组，和k，返回所有可能的 k 个数的组合。】要3，4结合使用。
~排列是有序的，组合是无序的；